/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "rpc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTSProtocolVersionValues[] = {
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V1,
  TSProtocolVersion::IOTDB_SERVICE_PROTOCOL_V2
};
const char* _kTSProtocolVersionNames[] = {
  "IOTDB_SERVICE_PROTOCOL_V1",
  "IOTDB_SERVICE_PROTOCOL_V2"
};
const std::map<int, const char*> _TSProtocolVersion_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kTSProtocolVersionValues, _kTSProtocolVersionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const TSProtocolVersion::type& val) {
  std::map<int, const char*>::const_iterator it = _TSProtocolVersion_VALUES_TO_NAMES.find(val);
  if (it != _TSProtocolVersion_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


TSStatus::~TSStatus() noexcept {
}


void TSStatus::__set_code(const int32_t val) {
  this->code = val;
}

void TSStatus::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const TSStatus& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSStatus");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSStatus &a, TSStatus &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

TSStatus::TSStatus(const TSStatus& other0) {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
TSStatus& TSStatus::operator=(const TSStatus& other1) {
  code = other1.code;
  message = other1.message;
  __isset = other1.__isset;
  return *this;
}
void TSStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSStatus(";
  out << "code=" << to_string(code);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}


TSQueryDataSet::~TSQueryDataSet() noexcept {
}


void TSQueryDataSet::__set_time(const std::string& val) {
  this->time = val;
}

void TSQueryDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}

void TSQueryDataSet::__set_bitmapList(const std::vector<std::string> & val) {
  this->bitmapList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_time = false;
  bool isset_valueList = false;
  bool isset_bitmapList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->time);
          isset_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->valueList.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readBinary(this->valueList[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bitmapList.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->bitmapList.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readBinary(this->bitmapList[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bitmapList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bitmapList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryDataSet");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->valueList.begin(); _iter12 != this->valueList.end(); ++_iter12)
    {
      xfer += oprot->writeBinary((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bitmapList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bitmapList.size()));
    std::vector<std::string> ::const_iterator _iter13;
    for (_iter13 = this->bitmapList.begin(); _iter13 != this->bitmapList.end(); ++_iter13)
    {
      xfer += oprot->writeBinary((*_iter13));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryDataSet &a, TSQueryDataSet &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.valueList, b.valueList);
  swap(a.bitmapList, b.bitmapList);
}

TSQueryDataSet::TSQueryDataSet(const TSQueryDataSet& other14) {
  time = other14.time;
  valueList = other14.valueList;
  bitmapList = other14.bitmapList;
}
TSQueryDataSet& TSQueryDataSet::operator=(const TSQueryDataSet& other15) {
  time = other15.time;
  valueList = other15.valueList;
  bitmapList = other15.bitmapList;
  return *this;
}
void TSQueryDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryDataSet(";
  out << "time=" << to_string(time);
  out << ", " << "valueList=" << to_string(valueList);
  out << ", " << "bitmapList=" << to_string(bitmapList);
  out << ")";
}


TSQueryNonAlignDataSet::~TSQueryNonAlignDataSet() noexcept {
}


void TSQueryNonAlignDataSet::__set_timeList(const std::vector<std::string> & val) {
  this->timeList = val;
}

void TSQueryNonAlignDataSet::__set_valueList(const std::vector<std::string> & val) {
  this->valueList = val;
}
std::ostream& operator<<(std::ostream& out, const TSQueryNonAlignDataSet& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSQueryNonAlignDataSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_timeList = false;
  bool isset_valueList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timeList.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->timeList.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readBinary(this->timeList[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valueList.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->valueList.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readBinary(this->valueList[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valueList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_timeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valueList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSQueryNonAlignDataSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSQueryNonAlignDataSet");

  xfer += oprot->writeFieldBegin("timeList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timeList.size()));
    std::vector<std::string> ::const_iterator _iter26;
    for (_iter26 = this->timeList.begin(); _iter26 != this->timeList.end(); ++_iter26)
    {
      xfer += oprot->writeBinary((*_iter26));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valueList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valueList.size()));
    std::vector<std::string> ::const_iterator _iter27;
    for (_iter27 = this->valueList.begin(); _iter27 != this->valueList.end(); ++_iter27)
    {
      xfer += oprot->writeBinary((*_iter27));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSQueryNonAlignDataSet &a, TSQueryNonAlignDataSet &b) {
  using ::std::swap;
  swap(a.timeList, b.timeList);
  swap(a.valueList, b.valueList);
}

TSQueryNonAlignDataSet::TSQueryNonAlignDataSet(const TSQueryNonAlignDataSet& other28) {
  timeList = other28.timeList;
  valueList = other28.valueList;
}
TSQueryNonAlignDataSet& TSQueryNonAlignDataSet::operator=(const TSQueryNonAlignDataSet& other29) {
  timeList = other29.timeList;
  valueList = other29.valueList;
  return *this;
}
void TSQueryNonAlignDataSet::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSQueryNonAlignDataSet(";
  out << "timeList=" << to_string(timeList);
  out << ", " << "valueList=" << to_string(valueList);
  out << ")";
}


TSExecuteStatementResp::~TSExecuteStatementResp() noexcept {
}


void TSExecuteStatementResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSExecuteStatementResp::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSExecuteStatementResp::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
__isset.columns = true;
}

void TSExecuteStatementResp::__set_operationType(const std::string& val) {
  this->operationType = val;
__isset.operationType = true;
}

void TSExecuteStatementResp::__set_ignoreTimeStamp(const bool val) {
  this->ignoreTimeStamp = val;
__isset.ignoreTimeStamp = true;
}

void TSExecuteStatementResp::__set_dataTypeList(const std::vector<std::string> & val) {
  this->dataTypeList = val;
__isset.dataTypeList = true;
}

void TSExecuteStatementResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSExecuteStatementResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}

void TSExecuteStatementResp::__set_columnNameIndexMap(const std::map<std::string, int32_t> & val) {
  this->columnNameIndexMap = val;
__isset.columnNameIndexMap = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->columns.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readString(this->columns[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operationType);
          this->__isset.operationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ignoreTimeStamp);
          this->__isset.ignoreTimeStamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypeList.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->dataTypeList.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += iprot->readString(this->dataTypeList[_i39]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataTypeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->columnNameIndexMap.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _ktype41;
            ::apache::thrift::protocol::TType _vtype42;
            xfer += iprot->readMapBegin(_ktype41, _vtype42, _size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              std::string _key45;
              xfer += iprot->readString(_key45);
              int32_t& _val46 = this->columnNameIndexMap[_key45];
              xfer += iprot->readI32(_val46);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.columnNameIndexMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columns) {
    xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
      std::vector<std::string> ::const_iterator _iter47;
      for (_iter47 = this->columns.begin(); _iter47 != this->columns.end(); ++_iter47)
      {
        xfer += oprot->writeString((*_iter47));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationType) {
    xfer += oprot->writeFieldBegin("operationType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->operationType);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ignoreTimeStamp) {
    xfer += oprot->writeFieldBegin("ignoreTimeStamp", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->ignoreTimeStamp);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataTypeList) {
    xfer += oprot->writeFieldBegin("dataTypeList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->dataTypeList.size()));
      std::vector<std::string> ::const_iterator _iter48;
      for (_iter48 = this->dataTypeList.begin(); _iter48 != this->dataTypeList.end(); ++_iter48)
      {
        xfer += oprot->writeString((*_iter48));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnNameIndexMap) {
    xfer += oprot->writeFieldBegin("columnNameIndexMap", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->columnNameIndexMap.size()));
      std::map<std::string, int32_t> ::const_iterator _iter49;
      for (_iter49 = this->columnNameIndexMap.begin(); _iter49 != this->columnNameIndexMap.end(); ++_iter49)
      {
        xfer += oprot->writeString(_iter49->first);
        xfer += oprot->writeI32(_iter49->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementResp &a, TSExecuteStatementResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.queryId, b.queryId);
  swap(a.columns, b.columns);
  swap(a.operationType, b.operationType);
  swap(a.ignoreTimeStamp, b.ignoreTimeStamp);
  swap(a.dataTypeList, b.dataTypeList);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.columnNameIndexMap, b.columnNameIndexMap);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementResp::TSExecuteStatementResp(const TSExecuteStatementResp& other50) {
  status = other50.status;
  queryId = other50.queryId;
  columns = other50.columns;
  operationType = other50.operationType;
  ignoreTimeStamp = other50.ignoreTimeStamp;
  dataTypeList = other50.dataTypeList;
  queryDataSet = other50.queryDataSet;
  nonAlignQueryDataSet = other50.nonAlignQueryDataSet;
  columnNameIndexMap = other50.columnNameIndexMap;
  __isset = other50.__isset;
}
TSExecuteStatementResp& TSExecuteStatementResp::operator=(const TSExecuteStatementResp& other51) {
  status = other51.status;
  queryId = other51.queryId;
  columns = other51.columns;
  operationType = other51.operationType;
  ignoreTimeStamp = other51.ignoreTimeStamp;
  dataTypeList = other51.dataTypeList;
  queryDataSet = other51.queryDataSet;
  nonAlignQueryDataSet = other51.nonAlignQueryDataSet;
  columnNameIndexMap = other51.columnNameIndexMap;
  __isset = other51.__isset;
  return *this;
}
void TSExecuteStatementResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementResp(";
  out << "status=" << to_string(status);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "columns="; (__isset.columns ? (out << to_string(columns)) : (out << "<null>"));
  out << ", " << "operationType="; (__isset.operationType ? (out << to_string(operationType)) : (out << "<null>"));
  out << ", " << "ignoreTimeStamp="; (__isset.ignoreTimeStamp ? (out << to_string(ignoreTimeStamp)) : (out << "<null>"));
  out << ", " << "dataTypeList="; (__isset.dataTypeList ? (out << to_string(dataTypeList)) : (out << "<null>"));
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ", " << "columnNameIndexMap="; (__isset.columnNameIndexMap ? (out << to_string(columnNameIndexMap)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionResp::~TSOpenSessionResp() noexcept {
}


void TSOpenSessionResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSOpenSessionResp::__set_serverProtocolVersion(const TSProtocolVersion::type val) {
  this->serverProtocolVersion = val;
}

void TSOpenSessionResp::__set_sessionId(const int64_t val) {
  this->sessionId = val;
__isset.sessionId = true;
}

void TSOpenSessionResp::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_serverProtocolVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->serverProtocolVersion = (TSProtocolVersion::type)ecast52;
          isset_serverProtocolVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          this->__isset.sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _ktype54;
            ::apache::thrift::protocol::TType _vtype55;
            xfer += iprot->readMapBegin(_ktype54, _vtype55, _size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              std::string _key58;
              xfer += iprot->readString(_key58);
              std::string& _val59 = this->configuration[_key58];
              xfer += iprot->readString(_val59);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_serverProtocolVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverProtocolVersion", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->serverProtocolVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sessionId) {
    xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->sessionId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter60;
      for (_iter60 = this->configuration.begin(); _iter60 != this->configuration.end(); ++_iter60)
      {
        xfer += oprot->writeString(_iter60->first);
        xfer += oprot->writeString(_iter60->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionResp &a, TSOpenSessionResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.serverProtocolVersion, b.serverProtocolVersion);
  swap(a.sessionId, b.sessionId);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionResp::TSOpenSessionResp(const TSOpenSessionResp& other61) {
  status = other61.status;
  serverProtocolVersion = other61.serverProtocolVersion;
  sessionId = other61.sessionId;
  configuration = other61.configuration;
  __isset = other61.__isset;
}
TSOpenSessionResp& TSOpenSessionResp::operator=(const TSOpenSessionResp& other62) {
  status = other62.status;
  serverProtocolVersion = other62.serverProtocolVersion;
  sessionId = other62.sessionId;
  configuration = other62.configuration;
  __isset = other62.__isset;
  return *this;
}
void TSOpenSessionResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionResp(";
  out << "status=" << to_string(status);
  out << ", " << "serverProtocolVersion=" << to_string(serverProtocolVersion);
  out << ", " << "sessionId="; (__isset.sessionId ? (out << to_string(sessionId)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSOpenSessionReq::~TSOpenSessionReq() noexcept {
}


void TSOpenSessionReq::__set_client_protocol(const TSProtocolVersion::type val) {
  this->client_protocol = val;
}

void TSOpenSessionReq::__set_username(const std::string& val) {
  this->username = val;
__isset.username = true;
}

void TSOpenSessionReq::__set_password(const std::string& val) {
  this->password = val;
__isset.password = true;
}

void TSOpenSessionReq::__set_configuration(const std::map<std::string, std::string> & val) {
  this->configuration = val;
__isset.configuration = true;
}
std::ostream& operator<<(std::ostream& out, const TSOpenSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSOpenSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_client_protocol = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->client_protocol = (TSProtocolVersion::type)ecast63;
          isset_client_protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->username);
          this->__isset.username = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->configuration.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _ktype65;
            ::apache::thrift::protocol::TType _vtype66;
            xfer += iprot->readMapBegin(_ktype65, _vtype66, _size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              std::string _key69;
              xfer += iprot->readString(_key69);
              std::string& _val70 = this->configuration[_key69];
              xfer += iprot->readString(_val70);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.configuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_client_protocol)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSOpenSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSOpenSessionReq");

  xfer += oprot->writeFieldBegin("client_protocol", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->client_protocol);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.username) {
    xfer += oprot->writeFieldBegin("username", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->username);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.password) {
    xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->password);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.configuration) {
    xfer += oprot->writeFieldBegin("configuration", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->configuration.size()));
      std::map<std::string, std::string> ::const_iterator _iter71;
      for (_iter71 = this->configuration.begin(); _iter71 != this->configuration.end(); ++_iter71)
      {
        xfer += oprot->writeString(_iter71->first);
        xfer += oprot->writeString(_iter71->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSOpenSessionReq &a, TSOpenSessionReq &b) {
  using ::std::swap;
  swap(a.client_protocol, b.client_protocol);
  swap(a.username, b.username);
  swap(a.password, b.password);
  swap(a.configuration, b.configuration);
  swap(a.__isset, b.__isset);
}

TSOpenSessionReq::TSOpenSessionReq(const TSOpenSessionReq& other72) {
  client_protocol = other72.client_protocol;
  username = other72.username;
  password = other72.password;
  configuration = other72.configuration;
  __isset = other72.__isset;
}
TSOpenSessionReq& TSOpenSessionReq::operator=(const TSOpenSessionReq& other73) {
  client_protocol = other73.client_protocol;
  username = other73.username;
  password = other73.password;
  configuration = other73.configuration;
  __isset = other73.__isset;
  return *this;
}
void TSOpenSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSOpenSessionReq(";
  out << "client_protocol=" << to_string(client_protocol);
  out << ", " << "username="; (__isset.username ? (out << to_string(username)) : (out << "<null>"));
  out << ", " << "password="; (__isset.password ? (out << to_string(password)) : (out << "<null>"));
  out << ", " << "configuration="; (__isset.configuration ? (out << to_string(configuration)) : (out << "<null>"));
  out << ")";
}


TSCloseSessionReq::~TSCloseSessionReq() noexcept {
}


void TSCloseSessionReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCloseSessionReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseSessionReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseSessionReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseSessionReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseSessionReq &a, TSCloseSessionReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
}

TSCloseSessionReq::TSCloseSessionReq(const TSCloseSessionReq& other74) {
  sessionId = other74.sessionId;
}
TSCloseSessionReq& TSCloseSessionReq::operator=(const TSCloseSessionReq& other75) {
  sessionId = other75.sessionId;
  return *this;
}
void TSCloseSessionReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseSessionReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ")";
}


TSExecuteStatementReq::~TSExecuteStatementReq() noexcept {
}


void TSExecuteStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteStatementReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSExecuteStatementReq::__set_statementId(const int64_t val) {
  this->statementId = val;
}

void TSExecuteStatementReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
__isset.fetchSize = true;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_statementId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          isset_statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          this->__isset.fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statementId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->statementId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.fetchSize) {
    xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->fetchSize);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteStatementReq &a, TSExecuteStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.statementId, b.statementId);
  swap(a.fetchSize, b.fetchSize);
  swap(a.__isset, b.__isset);
}

TSExecuteStatementReq::TSExecuteStatementReq(const TSExecuteStatementReq& other76) {
  sessionId = other76.sessionId;
  statement = other76.statement;
  statementId = other76.statementId;
  fetchSize = other76.fetchSize;
  __isset = other76.__isset;
}
TSExecuteStatementReq& TSExecuteStatementReq::operator=(const TSExecuteStatementReq& other77) {
  sessionId = other77.sessionId;
  statement = other77.statement;
  statementId = other77.statementId;
  fetchSize = other77.fetchSize;
  __isset = other77.__isset;
  return *this;
}
void TSExecuteStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "statementId=" << to_string(statementId);
  out << ", " << "fetchSize="; (__isset.fetchSize ? (out << to_string(fetchSize)) : (out << "<null>"));
  out << ")";
}


TSExecuteBatchStatementResp::~TSExecuteBatchStatementResp() noexcept {
}


void TSExecuteBatchStatementResp::__set_statusList(const std::vector<TSStatus> & val) {
  this->statusList = val;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteBatchStatementResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteBatchStatementResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_statusList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statusList.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->statusList.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->statusList[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_statusList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_statusList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteBatchStatementResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteBatchStatementResp");

  xfer += oprot->writeFieldBegin("statusList", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statusList.size()));
    std::vector<TSStatus> ::const_iterator _iter83;
    for (_iter83 = this->statusList.begin(); _iter83 != this->statusList.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteBatchStatementResp &a, TSExecuteBatchStatementResp &b) {
  using ::std::swap;
  swap(a.statusList, b.statusList);
}

TSExecuteBatchStatementResp::TSExecuteBatchStatementResp(const TSExecuteBatchStatementResp& other84) {
  statusList = other84.statusList;
}
TSExecuteBatchStatementResp& TSExecuteBatchStatementResp::operator=(const TSExecuteBatchStatementResp& other85) {
  statusList = other85.statusList;
  return *this;
}
void TSExecuteBatchStatementResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteBatchStatementResp(";
  out << "statusList=" << to_string(statusList);
  out << ")";
}


TSExecuteBatchStatementReq::~TSExecuteBatchStatementReq() noexcept {
}


void TSExecuteBatchStatementReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSExecuteBatchStatementReq::__set_statements(const std::vector<std::string> & val) {
  this->statements = val;
}
std::ostream& operator<<(std::ostream& out, const TSExecuteBatchStatementReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSExecuteBatchStatementReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statements = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statements.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->statements.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += iprot->readString(this->statements[_i90]);
            }
            xfer += iprot->readListEnd();
          }
          isset_statements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSExecuteBatchStatementReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSExecuteBatchStatementReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statements", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->statements.size()));
    std::vector<std::string> ::const_iterator _iter91;
    for (_iter91 = this->statements.begin(); _iter91 != this->statements.end(); ++_iter91)
    {
      xfer += oprot->writeString((*_iter91));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSExecuteBatchStatementReq &a, TSExecuteBatchStatementReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statements, b.statements);
}

TSExecuteBatchStatementReq::TSExecuteBatchStatementReq(const TSExecuteBatchStatementReq& other92) {
  sessionId = other92.sessionId;
  statements = other92.statements;
}
TSExecuteBatchStatementReq& TSExecuteBatchStatementReq::operator=(const TSExecuteBatchStatementReq& other93) {
  sessionId = other93.sessionId;
  statements = other93.statements;
  return *this;
}
void TSExecuteBatchStatementReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSExecuteBatchStatementReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statements=" << to_string(statements);
  out << ")";
}


TSGetOperationStatusReq::~TSGetOperationStatusReq() noexcept {
}


void TSGetOperationStatusReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSGetOperationStatusReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetOperationStatusReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetOperationStatusReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetOperationStatusReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetOperationStatusReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetOperationStatusReq &a, TSGetOperationStatusReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSGetOperationStatusReq::TSGetOperationStatusReq(const TSGetOperationStatusReq& other94) {
  sessionId = other94.sessionId;
  queryId = other94.queryId;
}
TSGetOperationStatusReq& TSGetOperationStatusReq::operator=(const TSGetOperationStatusReq& other95) {
  sessionId = other95.sessionId;
  queryId = other95.queryId;
  return *this;
}
void TSGetOperationStatusReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetOperationStatusReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCancelOperationReq::~TSCancelOperationReq() noexcept {
}


void TSCancelOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCancelOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}
std::ostream& operator<<(std::ostream& out, const TSCancelOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCancelOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_queryId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCancelOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCancelOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCancelOperationReq &a, TSCancelOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
}

TSCancelOperationReq::TSCancelOperationReq(const TSCancelOperationReq& other96) {
  sessionId = other96.sessionId;
  queryId = other96.queryId;
}
TSCancelOperationReq& TSCancelOperationReq::operator=(const TSCancelOperationReq& other97) {
  sessionId = other97.sessionId;
  queryId = other97.queryId;
  return *this;
}
void TSCancelOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCancelOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId=" << to_string(queryId);
  out << ")";
}


TSCloseOperationReq::~TSCloseOperationReq() noexcept {
}


void TSCloseOperationReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCloseOperationReq::__set_queryId(const int64_t val) {
  this->queryId = val;
__isset.queryId = true;
}

void TSCloseOperationReq::__set_statementId(const int64_t val) {
  this->statementId = val;
__isset.statementId = true;
}
std::ostream& operator<<(std::ostream& out, const TSCloseOperationReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCloseOperationReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          this->__isset.queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->statementId);
          this->__isset.statementId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCloseOperationReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCloseOperationReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryId) {
    xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->queryId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.statementId) {
    xfer += oprot->writeFieldBegin("statementId", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->statementId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCloseOperationReq &a, TSCloseOperationReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.queryId, b.queryId);
  swap(a.statementId, b.statementId);
  swap(a.__isset, b.__isset);
}

TSCloseOperationReq::TSCloseOperationReq(const TSCloseOperationReq& other98) {
  sessionId = other98.sessionId;
  queryId = other98.queryId;
  statementId = other98.statementId;
  __isset = other98.__isset;
}
TSCloseOperationReq& TSCloseOperationReq::operator=(const TSCloseOperationReq& other99) {
  sessionId = other99.sessionId;
  queryId = other99.queryId;
  statementId = other99.statementId;
  __isset = other99.__isset;
  return *this;
}
void TSCloseOperationReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCloseOperationReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "queryId="; (__isset.queryId ? (out << to_string(queryId)) : (out << "<null>"));
  out << ", " << "statementId="; (__isset.statementId ? (out << to_string(statementId)) : (out << "<null>"));
  out << ")";
}


TSFetchResultsReq::~TSFetchResultsReq() noexcept {
}


void TSFetchResultsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchResultsReq::__set_statement(const std::string& val) {
  this->statement = val;
}

void TSFetchResultsReq::__set_fetchSize(const int32_t val) {
  this->fetchSize = val;
}

void TSFetchResultsReq::__set_queryId(const int64_t val) {
  this->queryId = val;
}

void TSFetchResultsReq::__set_isAlign(const bool val) {
  this->isAlign = val;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_statement = false;
  bool isset_fetchSize = false;
  bool isset_queryId = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->statement);
          isset_statement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fetchSize);
          isset_fetchSize = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->queryId);
          isset_queryId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_statement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_fetchSize)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_queryId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statement", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->statement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fetchSize", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->fetchSize);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("queryId", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->queryId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsReq &a, TSFetchResultsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.statement, b.statement);
  swap(a.fetchSize, b.fetchSize);
  swap(a.queryId, b.queryId);
  swap(a.isAlign, b.isAlign);
}

TSFetchResultsReq::TSFetchResultsReq(const TSFetchResultsReq& other100) {
  sessionId = other100.sessionId;
  statement = other100.statement;
  fetchSize = other100.fetchSize;
  queryId = other100.queryId;
  isAlign = other100.isAlign;
}
TSFetchResultsReq& TSFetchResultsReq::operator=(const TSFetchResultsReq& other101) {
  sessionId = other101.sessionId;
  statement = other101.statement;
  fetchSize = other101.fetchSize;
  queryId = other101.queryId;
  isAlign = other101.isAlign;
  return *this;
}
void TSFetchResultsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "statement=" << to_string(statement);
  out << ", " << "fetchSize=" << to_string(fetchSize);
  out << ", " << "queryId=" << to_string(queryId);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ")";
}


TSFetchResultsResp::~TSFetchResultsResp() noexcept {
}


void TSFetchResultsResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSFetchResultsResp::__set_hasResultSet(const bool val) {
  this->hasResultSet = val;
}

void TSFetchResultsResp::__set_isAlign(const bool val) {
  this->isAlign = val;
}

void TSFetchResultsResp::__set_queryDataSet(const TSQueryDataSet& val) {
  this->queryDataSet = val;
__isset.queryDataSet = true;
}

void TSFetchResultsResp::__set_nonAlignQueryDataSet(const TSQueryNonAlignDataSet& val) {
  this->nonAlignQueryDataSet = val;
__isset.nonAlignQueryDataSet = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchResultsResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchResultsResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_hasResultSet = false;
  bool isset_isAlign = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->hasResultSet);
          isset_hasResultSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isAlign);
          isset_isAlign = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->queryDataSet.read(iprot);
          this->__isset.queryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->nonAlignQueryDataSet.read(iprot);
          this->__isset.nonAlignQueryDataSet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_hasResultSet)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isAlign)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchResultsResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchResultsResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hasResultSet", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->hasResultSet);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isAlign", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->isAlign);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.queryDataSet) {
    xfer += oprot->writeFieldBegin("queryDataSet", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->queryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nonAlignQueryDataSet) {
    xfer += oprot->writeFieldBegin("nonAlignQueryDataSet", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->nonAlignQueryDataSet.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchResultsResp &a, TSFetchResultsResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.hasResultSet, b.hasResultSet);
  swap(a.isAlign, b.isAlign);
  swap(a.queryDataSet, b.queryDataSet);
  swap(a.nonAlignQueryDataSet, b.nonAlignQueryDataSet);
  swap(a.__isset, b.__isset);
}

TSFetchResultsResp::TSFetchResultsResp(const TSFetchResultsResp& other102) {
  status = other102.status;
  hasResultSet = other102.hasResultSet;
  isAlign = other102.isAlign;
  queryDataSet = other102.queryDataSet;
  nonAlignQueryDataSet = other102.nonAlignQueryDataSet;
  __isset = other102.__isset;
}
TSFetchResultsResp& TSFetchResultsResp::operator=(const TSFetchResultsResp& other103) {
  status = other103.status;
  hasResultSet = other103.hasResultSet;
  isAlign = other103.isAlign;
  queryDataSet = other103.queryDataSet;
  nonAlignQueryDataSet = other103.nonAlignQueryDataSet;
  __isset = other103.__isset;
  return *this;
}
void TSFetchResultsResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchResultsResp(";
  out << "status=" << to_string(status);
  out << ", " << "hasResultSet=" << to_string(hasResultSet);
  out << ", " << "isAlign=" << to_string(isAlign);
  out << ", " << "queryDataSet="; (__isset.queryDataSet ? (out << to_string(queryDataSet)) : (out << "<null>"));
  out << ", " << "nonAlignQueryDataSet="; (__isset.nonAlignQueryDataSet ? (out << to_string(nonAlignQueryDataSet)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataResp::~TSFetchMetadataResp() noexcept {
}


void TSFetchMetadataResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSFetchMetadataResp::__set_metadataInJson(const std::string& val) {
  this->metadataInJson = val;
__isset.metadataInJson = true;
}

void TSFetchMetadataResp::__set_columnsList(const std::vector<std::string> & val) {
  this->columnsList = val;
__isset.columnsList = true;
}

void TSFetchMetadataResp::__set_dataType(const std::string& val) {
  this->dataType = val;
__isset.dataType = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metadataInJson);
          this->__isset.metadataInJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columnsList.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->columnsList.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += iprot->readString(this->columnsList[_i108]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataType);
          this->__isset.dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.metadataInJson) {
    xfer += oprot->writeFieldBegin("metadataInJson", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->metadataInJson);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.columnsList) {
    xfer += oprot->writeFieldBegin("columnsList", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columnsList.size()));
      std::vector<std::string> ::const_iterator _iter109;
      for (_iter109 = this->columnsList.begin(); _iter109 != this->columnsList.end(); ++_iter109)
      {
        xfer += oprot->writeString((*_iter109));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dataType) {
    xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dataType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataResp &a, TSFetchMetadataResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.metadataInJson, b.metadataInJson);
  swap(a.columnsList, b.columnsList);
  swap(a.dataType, b.dataType);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataResp::TSFetchMetadataResp(const TSFetchMetadataResp& other110) {
  status = other110.status;
  metadataInJson = other110.metadataInJson;
  columnsList = other110.columnsList;
  dataType = other110.dataType;
  __isset = other110.__isset;
}
TSFetchMetadataResp& TSFetchMetadataResp::operator=(const TSFetchMetadataResp& other111) {
  status = other111.status;
  metadataInJson = other111.metadataInJson;
  columnsList = other111.columnsList;
  dataType = other111.dataType;
  __isset = other111.__isset;
  return *this;
}
void TSFetchMetadataResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataResp(";
  out << "status=" << to_string(status);
  out << ", " << "metadataInJson="; (__isset.metadataInJson ? (out << to_string(metadataInJson)) : (out << "<null>"));
  out << ", " << "columnsList="; (__isset.columnsList ? (out << to_string(columnsList)) : (out << "<null>"));
  out << ", " << "dataType="; (__isset.dataType ? (out << to_string(dataType)) : (out << "<null>"));
  out << ")";
}


TSFetchMetadataReq::~TSFetchMetadataReq() noexcept {
}


void TSFetchMetadataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSFetchMetadataReq::__set_type(const std::string& val) {
  this->type = val;
}

void TSFetchMetadataReq::__set_columnPath(const std::string& val) {
  this->columnPath = val;
__isset.columnPath = true;
}
std::ostream& operator<<(std::ostream& out, const TSFetchMetadataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSFetchMetadataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->columnPath);
          this->__isset.columnPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSFetchMetadataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSFetchMetadataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.columnPath) {
    xfer += oprot->writeFieldBegin("columnPath", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->columnPath);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSFetchMetadataReq &a, TSFetchMetadataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.type, b.type);
  swap(a.columnPath, b.columnPath);
  swap(a.__isset, b.__isset);
}

TSFetchMetadataReq::TSFetchMetadataReq(const TSFetchMetadataReq& other112) {
  sessionId = other112.sessionId;
  type = other112.type;
  columnPath = other112.columnPath;
  __isset = other112.__isset;
}
TSFetchMetadataReq& TSFetchMetadataReq::operator=(const TSFetchMetadataReq& other113) {
  sessionId = other113.sessionId;
  type = other113.type;
  columnPath = other113.columnPath;
  __isset = other113.__isset;
  return *this;
}
void TSFetchMetadataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSFetchMetadataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "type=" << to_string(type);
  out << ", " << "columnPath="; (__isset.columnPath ? (out << to_string(columnPath)) : (out << "<null>"));
  out << ")";
}


TSGetTimeZoneResp::~TSGetTimeZoneResp() noexcept {
}


void TSGetTimeZoneResp::__set_status(const TSStatus& val) {
  this->status = val;
}

void TSGetTimeZoneResp::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSGetTimeZoneResp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSGetTimeZoneResp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_status = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSGetTimeZoneResp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSGetTimeZoneResp");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSGetTimeZoneResp &a, TSGetTimeZoneResp &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.timeZone, b.timeZone);
}

TSGetTimeZoneResp::TSGetTimeZoneResp(const TSGetTimeZoneResp& other114) {
  status = other114.status;
  timeZone = other114.timeZone;
}
TSGetTimeZoneResp& TSGetTimeZoneResp::operator=(const TSGetTimeZoneResp& other115) {
  status = other115.status;
  timeZone = other115.timeZone;
  return *this;
}
void TSGetTimeZoneResp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSGetTimeZoneResp(";
  out << "status=" << to_string(status);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSSetTimeZoneReq::~TSSetTimeZoneReq() noexcept {
}


void TSSetTimeZoneReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSSetTimeZoneReq::__set_timeZone(const std::string& val) {
  this->timeZone = val;
}
std::ostream& operator<<(std::ostream& out, const TSSetTimeZoneReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSSetTimeZoneReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_timeZone = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timeZone);
          isset_timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSSetTimeZoneReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSSetTimeZoneReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeZone", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSSetTimeZoneReq &a, TSSetTimeZoneReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.timeZone, b.timeZone);
}

TSSetTimeZoneReq::TSSetTimeZoneReq(const TSSetTimeZoneReq& other116) {
  sessionId = other116.sessionId;
  timeZone = other116.timeZone;
}
TSSetTimeZoneReq& TSSetTimeZoneReq::operator=(const TSSetTimeZoneReq& other117) {
  sessionId = other117.sessionId;
  timeZone = other117.timeZone;
  return *this;
}
void TSSetTimeZoneReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSSetTimeZoneReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "timeZone=" << to_string(timeZone);
  out << ")";
}


TSInsertRecordReq::~TSInsertRecordReq() noexcept {
}


void TSInsertRecordReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertRecordReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertRecordReq::__set_values(const std::vector<std::string> & val) {
  this->values = val;
}

void TSInsertRecordReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->measurements.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readString(this->measurements[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _etype126;
            xfer += iprot->readListBegin(_etype126, _size123);
            this->values.resize(_size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              xfer += iprot->readString(this->values[_i127]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter128;
    for (_iter128 = this->measurements.begin(); _iter128 != this->measurements.end(); ++_iter128)
    {
      xfer += oprot->writeString((*_iter128));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->values.size()));
    std::vector<std::string> ::const_iterator _iter129;
    for (_iter129 = this->values.begin(); _iter129 != this->values.end(); ++_iter129)
    {
      xfer += oprot->writeString((*_iter129));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordReq &a, TSInsertRecordReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamp, b.timestamp);
}

TSInsertRecordReq::TSInsertRecordReq(const TSInsertRecordReq& other130) {
  sessionId = other130.sessionId;
  deviceId = other130.deviceId;
  measurements = other130.measurements;
  values = other130.values;
  timestamp = other130.timestamp;
}
TSInsertRecordReq& TSInsertRecordReq::operator=(const TSInsertRecordReq& other131) {
  sessionId = other131.sessionId;
  deviceId = other131.deviceId;
  measurements = other131.measurements;
  values = other131.values;
  timestamp = other131.timestamp;
  return *this;
}
void TSInsertRecordReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


TSInsertTabletReq::~TSInsertTabletReq() noexcept {
}


void TSInsertTabletReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletReq::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

void TSInsertTabletReq::__set_measurements(const std::vector<std::string> & val) {
  this->measurements = val;
}

void TSInsertTabletReq::__set_values(const std::string& val) {
  this->values = val;
}

void TSInsertTabletReq::__set_timestamps(const std::string& val) {
  this->timestamps = val;
}

void TSInsertTabletReq::__set_types(const std::vector<int32_t> & val) {
  this->types = val;
}

void TSInsertTabletReq::__set_size(const int32_t val) {
  this->size = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceId = false;
  bool isset_measurements = false;
  bool isset_values = false;
  bool isset_timestamps = false;
  bool isset_types = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          isset_deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurements.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->measurements.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += iprot->readString(this->measurements[_i136]);
            }
            xfer += iprot->readListEnd();
          }
          isset_measurements = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->values);
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->timestamps);
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->types.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->types.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += iprot->readI32(this->types[_i141]);
            }
            xfer += iprot->readListEnd();
          }
          isset_types = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurements)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_types)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurements", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurements.size()));
    std::vector<std::string> ::const_iterator _iter142;
    for (_iter142 = this->measurements.begin(); _iter142 != this->measurements.end(); ++_iter142)
    {
      xfer += oprot->writeString((*_iter142));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->values);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->timestamps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("types", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->types.size()));
    std::vector<int32_t> ::const_iterator _iter143;
    for (_iter143 = this->types.begin(); _iter143 != this->types.end(); ++_iter143)
    {
      xfer += oprot->writeI32((*_iter143));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletReq &a, TSInsertTabletReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceId, b.deviceId);
  swap(a.measurements, b.measurements);
  swap(a.values, b.values);
  swap(a.timestamps, b.timestamps);
  swap(a.types, b.types);
  swap(a.size, b.size);
}

TSInsertTabletReq::TSInsertTabletReq(const TSInsertTabletReq& other144) {
  sessionId = other144.sessionId;
  deviceId = other144.deviceId;
  measurements = other144.measurements;
  values = other144.values;
  timestamps = other144.timestamps;
  types = other144.types;
  size = other144.size;
}
TSInsertTabletReq& TSInsertTabletReq::operator=(const TSInsertTabletReq& other145) {
  sessionId = other145.sessionId;
  deviceId = other145.deviceId;
  measurements = other145.measurements;
  values = other145.values;
  timestamps = other145.timestamps;
  types = other145.types;
  size = other145.size;
  return *this;
}
void TSInsertTabletReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceId=" << to_string(deviceId);
  out << ", " << "measurements=" << to_string(measurements);
  out << ", " << "values=" << to_string(values);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ", " << "types=" << to_string(types);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


TSInsertTabletsReq::~TSInsertTabletsReq() noexcept {
}


void TSInsertTabletsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertTabletsReq::__set_deviceIds(const std::vector<std::string> & val) {
  this->deviceIds = val;
}

void TSInsertTabletsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertTabletsReq::__set_valuesList(const std::vector<std::string> & val) {
  this->valuesList = val;
}

void TSInsertTabletsReq::__set_timestampsList(const std::vector<std::string> & val) {
  this->timestampsList = val;
}

void TSInsertTabletsReq::__set_typesList(const std::vector<std::vector<int32_t> > & val) {
  this->typesList = val;
}

void TSInsertTabletsReq::__set_sizeList(const std::vector<int32_t> & val) {
  this->sizeList = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertTabletsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertTabletsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceIds = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestampsList = false;
  bool isset_typesList = false;
  bool isset_sizeList = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceIds.clear();
            uint32_t _size146;
            ::apache::thrift::protocol::TType _etype149;
            xfer += iprot->readListBegin(_etype149, _size146);
            this->deviceIds.resize(_size146);
            uint32_t _i150;
            for (_i150 = 0; _i150 < _size146; ++_i150)
            {
              xfer += iprot->readString(this->deviceIds[_i150]);
            }
            xfer += iprot->readListEnd();
          }
          isset_deviceIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size151;
            ::apache::thrift::protocol::TType _etype154;
            xfer += iprot->readListBegin(_etype154, _size151);
            this->measurementsList.resize(_size151);
            uint32_t _i155;
            for (_i155 = 0; _i155 < _size151; ++_i155)
            {
              {
                this->measurementsList[_i155].clear();
                uint32_t _size156;
                ::apache::thrift::protocol::TType _etype159;
                xfer += iprot->readListBegin(_etype159, _size156);
                this->measurementsList[_i155].resize(_size156);
                uint32_t _i160;
                for (_i160 = 0; _i160 < _size156; ++_i160)
                {
                  xfer += iprot->readString(this->measurementsList[_i155][_i160]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size161;
            ::apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size161);
            this->valuesList.resize(_size161);
            uint32_t _i165;
            for (_i165 = 0; _i165 < _size161; ++_i165)
            {
              xfer += iprot->readBinary(this->valuesList[_i165]);
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestampsList.clear();
            uint32_t _size166;
            ::apache::thrift::protocol::TType _etype169;
            xfer += iprot->readListBegin(_etype169, _size166);
            this->timestampsList.resize(_size166);
            uint32_t _i170;
            for (_i170 = 0; _i170 < _size166; ++_i170)
            {
              xfer += iprot->readBinary(this->timestampsList[_i170]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestampsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->typesList.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->typesList.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              {
                this->typesList[_i175].clear();
                uint32_t _size176;
                ::apache::thrift::protocol::TType _etype179;
                xfer += iprot->readListBegin(_etype179, _size176);
                this->typesList[_i175].resize(_size176);
                uint32_t _i180;
                for (_i180 = 0; _i180 < _size176; ++_i180)
                {
                  xfer += iprot->readI32(this->typesList[_i175][_i180]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_typesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sizeList.clear();
            uint32_t _size181;
            ::apache::thrift::protocol::TType _etype184;
            xfer += iprot->readListBegin(_etype184, _size181);
            this->sizeList.resize(_size181);
            uint32_t _i185;
            for (_i185 = 0; _i185 < _size181; ++_i185)
            {
              xfer += iprot->readI32(this->sizeList[_i185]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sizeList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_typesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sizeList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertTabletsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertTabletsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deviceIds.size()));
    std::vector<std::string> ::const_iterator _iter186;
    for (_iter186 = this->deviceIds.begin(); _iter186 != this->deviceIds.end(); ++_iter186)
    {
      xfer += oprot->writeString((*_iter186));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter187;
    for (_iter187 = this->measurementsList.begin(); _iter187 != this->measurementsList.end(); ++_iter187)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter187).size()));
        std::vector<std::string> ::const_iterator _iter188;
        for (_iter188 = (*_iter187).begin(); _iter188 != (*_iter187).end(); ++_iter188)
        {
          xfer += oprot->writeString((*_iter188));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::string> ::const_iterator _iter189;
    for (_iter189 = this->valuesList.begin(); _iter189 != this->valuesList.end(); ++_iter189)
    {
      xfer += oprot->writeBinary((*_iter189));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampsList", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->timestampsList.size()));
    std::vector<std::string> ::const_iterator _iter190;
    for (_iter190 = this->timestampsList.begin(); _iter190 != this->timestampsList.end(); ++_iter190)
    {
      xfer += oprot->writeBinary((*_iter190));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typesList", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->typesList.size()));
    std::vector<std::vector<int32_t> > ::const_iterator _iter191;
    for (_iter191 = this->typesList.begin(); _iter191 != this->typesList.end(); ++_iter191)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*_iter191).size()));
        std::vector<int32_t> ::const_iterator _iter192;
        for (_iter192 = (*_iter191).begin(); _iter192 != (*_iter191).end(); ++_iter192)
        {
          xfer += oprot->writeI32((*_iter192));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sizeList", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->sizeList.size()));
    std::vector<int32_t> ::const_iterator _iter193;
    for (_iter193 = this->sizeList.begin(); _iter193 != this->sizeList.end(); ++_iter193)
    {
      xfer += oprot->writeI32((*_iter193));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertTabletsReq &a, TSInsertTabletsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceIds, b.deviceIds);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestampsList, b.timestampsList);
  swap(a.typesList, b.typesList);
  swap(a.sizeList, b.sizeList);
}

TSInsertTabletsReq::TSInsertTabletsReq(const TSInsertTabletsReq& other194) {
  sessionId = other194.sessionId;
  deviceIds = other194.deviceIds;
  measurementsList = other194.measurementsList;
  valuesList = other194.valuesList;
  timestampsList = other194.timestampsList;
  typesList = other194.typesList;
  sizeList = other194.sizeList;
}
TSInsertTabletsReq& TSInsertTabletsReq::operator=(const TSInsertTabletsReq& other195) {
  sessionId = other195.sessionId;
  deviceIds = other195.deviceIds;
  measurementsList = other195.measurementsList;
  valuesList = other195.valuesList;
  timestampsList = other195.timestampsList;
  typesList = other195.typesList;
  sizeList = other195.sizeList;
  return *this;
}
void TSInsertTabletsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertTabletsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceIds=" << to_string(deviceIds);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestampsList=" << to_string(timestampsList);
  out << ", " << "typesList=" << to_string(typesList);
  out << ", " << "sizeList=" << to_string(sizeList);
  out << ")";
}


TSInsertRecordsReq::~TSInsertRecordsReq() noexcept {
}


void TSInsertRecordsReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSInsertRecordsReq::__set_deviceIds(const std::vector<std::string> & val) {
  this->deviceIds = val;
}

void TSInsertRecordsReq::__set_measurementsList(const std::vector<std::vector<std::string> > & val) {
  this->measurementsList = val;
}

void TSInsertRecordsReq::__set_valuesList(const std::vector<std::vector<std::string> > & val) {
  this->valuesList = val;
}

void TSInsertRecordsReq::__set_timestamps(const std::vector<int64_t> & val) {
  this->timestamps = val;
}
std::ostream& operator<<(std::ostream& out, const TSInsertRecordsReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSInsertRecordsReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_deviceIds = false;
  bool isset_measurementsList = false;
  bool isset_valuesList = false;
  bool isset_timestamps = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->deviceIds.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _etype199;
            xfer += iprot->readListBegin(_etype199, _size196);
            this->deviceIds.resize(_size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              xfer += iprot->readString(this->deviceIds[_i200]);
            }
            xfer += iprot->readListEnd();
          }
          isset_deviceIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementsList.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->measurementsList.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              {
                this->measurementsList[_i205].clear();
                uint32_t _size206;
                ::apache::thrift::protocol::TType _etype209;
                xfer += iprot->readListBegin(_etype209, _size206);
                this->measurementsList[_i205].resize(_size206);
                uint32_t _i210;
                for (_i210 = 0; _i210 < _size206; ++_i210)
                {
                  xfer += iprot->readString(this->measurementsList[_i205][_i210]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_measurementsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->valuesList.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->valuesList.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              {
                this->valuesList[_i215].clear();
                uint32_t _size216;
                ::apache::thrift::protocol::TType _etype219;
                xfer += iprot->readListBegin(_etype219, _size216);
                this->valuesList[_i215].resize(_size216);
                uint32_t _i220;
                for (_i220 = 0; _i220 < _size216; ++_i220)
                {
                  xfer += iprot->readString(this->valuesList[_i215][_i220]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_valuesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->timestamps.clear();
            uint32_t _size221;
            ::apache::thrift::protocol::TType _etype224;
            xfer += iprot->readListBegin(_etype224, _size221);
            this->timestamps.resize(_size221);
            uint32_t _i225;
            for (_i225 = 0; _i225 < _size221; ++_i225)
            {
              xfer += iprot->readI64(this->timestamps[_i225]);
            }
            xfer += iprot->readListEnd();
          }
          isset_timestamps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_deviceIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_measurementsList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_valuesList)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSInsertRecordsReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSInsertRecordsReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deviceIds", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->deviceIds.size()));
    std::vector<std::string> ::const_iterator _iter226;
    for (_iter226 = this->deviceIds.begin(); _iter226 != this->deviceIds.end(); ++_iter226)
    {
      xfer += oprot->writeString((*_iter226));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("measurementsList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->measurementsList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter227;
    for (_iter227 = this->measurementsList.begin(); _iter227 != this->measurementsList.end(); ++_iter227)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter227).size()));
        std::vector<std::string> ::const_iterator _iter228;
        for (_iter228 = (*_iter227).begin(); _iter228 != (*_iter227).end(); ++_iter228)
        {
          xfer += oprot->writeString((*_iter228));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("valuesList", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->valuesList.size()));
    std::vector<std::vector<std::string> > ::const_iterator _iter229;
    for (_iter229 = this->valuesList.begin(); _iter229 != this->valuesList.end(); ++_iter229)
    {
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter229).size()));
        std::vector<std::string> ::const_iterator _iter230;
        for (_iter230 = (*_iter229).begin(); _iter230 != (*_iter229).end(); ++_iter230)
        {
          xfer += oprot->writeString((*_iter230));
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamps", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->timestamps.size()));
    std::vector<int64_t> ::const_iterator _iter231;
    for (_iter231 = this->timestamps.begin(); _iter231 != this->timestamps.end(); ++_iter231)
    {
      xfer += oprot->writeI64((*_iter231));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSInsertRecordsReq &a, TSInsertRecordsReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.deviceIds, b.deviceIds);
  swap(a.measurementsList, b.measurementsList);
  swap(a.valuesList, b.valuesList);
  swap(a.timestamps, b.timestamps);
}

TSInsertRecordsReq::TSInsertRecordsReq(const TSInsertRecordsReq& other232) {
  sessionId = other232.sessionId;
  deviceIds = other232.deviceIds;
  measurementsList = other232.measurementsList;
  valuesList = other232.valuesList;
  timestamps = other232.timestamps;
}
TSInsertRecordsReq& TSInsertRecordsReq::operator=(const TSInsertRecordsReq& other233) {
  sessionId = other233.sessionId;
  deviceIds = other233.deviceIds;
  measurementsList = other233.measurementsList;
  valuesList = other233.valuesList;
  timestamps = other233.timestamps;
  return *this;
}
void TSInsertRecordsReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSInsertRecordsReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "deviceIds=" << to_string(deviceIds);
  out << ", " << "measurementsList=" << to_string(measurementsList);
  out << ", " << "valuesList=" << to_string(valuesList);
  out << ", " << "timestamps=" << to_string(timestamps);
  out << ")";
}


TSDeleteDataReq::~TSDeleteDataReq() noexcept {
}


void TSDeleteDataReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSDeleteDataReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSDeleteDataReq::__set_timestamp(const int64_t val) {
  this->timestamp = val;
}
std::ostream& operator<<(std::ostream& out, const TSDeleteDataReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSDeleteDataReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_timestamp = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->paths.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += iprot->readString(this->paths[_i238]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timestamp);
          isset_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSDeleteDataReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSDeleteDataReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter239;
    for (_iter239 = this->paths.begin(); _iter239 != this->paths.end(); ++_iter239)
    {
      xfer += oprot->writeString((*_iter239));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSDeleteDataReq &a, TSDeleteDataReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.timestamp, b.timestamp);
}

TSDeleteDataReq::TSDeleteDataReq(const TSDeleteDataReq& other240) {
  sessionId = other240.sessionId;
  paths = other240.paths;
  timestamp = other240.timestamp;
}
TSDeleteDataReq& TSDeleteDataReq::operator=(const TSDeleteDataReq& other241) {
  sessionId = other241.sessionId;
  paths = other241.paths;
  timestamp = other241.timestamp;
  return *this;
}
void TSDeleteDataReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSDeleteDataReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


TSCreateTimeseriesReq::~TSCreateTimeseriesReq() noexcept {
}


void TSCreateTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateTimeseriesReq::__set_path(const std::string& val) {
  this->path = val;
}

void TSCreateTimeseriesReq::__set_dataType(const int32_t val) {
  this->dataType = val;
}

void TSCreateTimeseriesReq::__set_encoding(const int32_t val) {
  this->encoding = val;
}

void TSCreateTimeseriesReq::__set_compressor(const int32_t val) {
  this->compressor = val;
}

void TSCreateTimeseriesReq::__set_props(const std::map<std::string, std::string> & val) {
  this->props = val;
__isset.props = true;
}

void TSCreateTimeseriesReq::__set_tags(const std::map<std::string, std::string> & val) {
  this->tags = val;
__isset.tags = true;
}

void TSCreateTimeseriesReq::__set_attributes(const std::map<std::string, std::string> & val) {
  this->attributes = val;
__isset.attributes = true;
}

void TSCreateTimeseriesReq::__set_measurementAlias(const std::string& val) {
  this->measurementAlias = val;
__isset.measurementAlias = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_path = false;
  bool isset_dataType = false;
  bool isset_encoding = false;
  bool isset_compressor = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          isset_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dataType);
          isset_dataType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->encoding);
          isset_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->compressor);
          isset_compressor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->props.clear();
            uint32_t _size242;
            ::apache::thrift::protocol::TType _ktype243;
            ::apache::thrift::protocol::TType _vtype244;
            xfer += iprot->readMapBegin(_ktype243, _vtype244, _size242);
            uint32_t _i246;
            for (_i246 = 0; _i246 < _size242; ++_i246)
            {
              std::string _key247;
              xfer += iprot->readString(_key247);
              std::string& _val248 = this->props[_key247];
              xfer += iprot->readString(_val248);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.props = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->tags.clear();
            uint32_t _size249;
            ::apache::thrift::protocol::TType _ktype250;
            ::apache::thrift::protocol::TType _vtype251;
            xfer += iprot->readMapBegin(_ktype250, _vtype251, _size249);
            uint32_t _i253;
            for (_i253 = 0; _i253 < _size249; ++_i253)
            {
              std::string _key254;
              xfer += iprot->readString(_key254);
              std::string& _val255 = this->tags[_key254];
              xfer += iprot->readString(_val255);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->attributes.clear();
            uint32_t _size256;
            ::apache::thrift::protocol::TType _ktype257;
            ::apache::thrift::protocol::TType _vtype258;
            xfer += iprot->readMapBegin(_ktype257, _vtype258, _size256);
            uint32_t _i260;
            for (_i260 = 0; _i260 < _size256; ++_i260)
            {
              std::string _key261;
              xfer += iprot->readString(_key261);
              std::string& _val262 = this->attributes[_key261];
              xfer += iprot->readString(_val262);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.attributes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->measurementAlias);
          this->__isset.measurementAlias = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_path)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encoding)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressor)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->dataType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->encoding);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressor", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->compressor);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.props) {
    xfer += oprot->writeFieldBegin("props", ::apache::thrift::protocol::T_MAP, 6);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->props.size()));
      std::map<std::string, std::string> ::const_iterator _iter263;
      for (_iter263 = this->props.begin(); _iter263 != this->props.end(); ++_iter263)
      {
        xfer += oprot->writeString(_iter263->first);
        xfer += oprot->writeString(_iter263->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tags) {
    xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->tags.size()));
      std::map<std::string, std::string> ::const_iterator _iter264;
      for (_iter264 = this->tags.begin(); _iter264 != this->tags.end(); ++_iter264)
      {
        xfer += oprot->writeString(_iter264->first);
        xfer += oprot->writeString(_iter264->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributes) {
    xfer += oprot->writeFieldBegin("attributes", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->attributes.size()));
      std::map<std::string, std::string> ::const_iterator _iter265;
      for (_iter265 = this->attributes.begin(); _iter265 != this->attributes.end(); ++_iter265)
      {
        xfer += oprot->writeString(_iter265->first);
        xfer += oprot->writeString(_iter265->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAlias) {
    xfer += oprot->writeFieldBegin("measurementAlias", ::apache::thrift::protocol::T_STRING, 9);
    xfer += oprot->writeString(this->measurementAlias);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateTimeseriesReq &a, TSCreateTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.path, b.path);
  swap(a.dataType, b.dataType);
  swap(a.encoding, b.encoding);
  swap(a.compressor, b.compressor);
  swap(a.props, b.props);
  swap(a.tags, b.tags);
  swap(a.attributes, b.attributes);
  swap(a.measurementAlias, b.measurementAlias);
  swap(a.__isset, b.__isset);
}

TSCreateTimeseriesReq::TSCreateTimeseriesReq(const TSCreateTimeseriesReq& other266) {
  sessionId = other266.sessionId;
  path = other266.path;
  dataType = other266.dataType;
  encoding = other266.encoding;
  compressor = other266.compressor;
  props = other266.props;
  tags = other266.tags;
  attributes = other266.attributes;
  measurementAlias = other266.measurementAlias;
  __isset = other266.__isset;
}
TSCreateTimeseriesReq& TSCreateTimeseriesReq::operator=(const TSCreateTimeseriesReq& other267) {
  sessionId = other267.sessionId;
  path = other267.path;
  dataType = other267.dataType;
  encoding = other267.encoding;
  compressor = other267.compressor;
  props = other267.props;
  tags = other267.tags;
  attributes = other267.attributes;
  measurementAlias = other267.measurementAlias;
  __isset = other267.__isset;
  return *this;
}
void TSCreateTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "path=" << to_string(path);
  out << ", " << "dataType=" << to_string(dataType);
  out << ", " << "encoding=" << to_string(encoding);
  out << ", " << "compressor=" << to_string(compressor);
  out << ", " << "props="; (__isset.props ? (out << to_string(props)) : (out << "<null>"));
  out << ", " << "tags="; (__isset.tags ? (out << to_string(tags)) : (out << "<null>"));
  out << ", " << "attributes="; (__isset.attributes ? (out << to_string(attributes)) : (out << "<null>"));
  out << ", " << "measurementAlias="; (__isset.measurementAlias ? (out << to_string(measurementAlias)) : (out << "<null>"));
  out << ")";
}


TSCreateMultiTimeseriesReq::~TSCreateMultiTimeseriesReq() noexcept {
}


void TSCreateMultiTimeseriesReq::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void TSCreateMultiTimeseriesReq::__set_paths(const std::vector<std::string> & val) {
  this->paths = val;
}

void TSCreateMultiTimeseriesReq::__set_dataTypes(const std::vector<int32_t> & val) {
  this->dataTypes = val;
}

void TSCreateMultiTimeseriesReq::__set_encodings(const std::vector<int32_t> & val) {
  this->encodings = val;
}

void TSCreateMultiTimeseriesReq::__set_compressors(const std::vector<int32_t> & val) {
  this->compressors = val;
}

void TSCreateMultiTimeseriesReq::__set_propsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->propsList = val;
__isset.propsList = true;
}

void TSCreateMultiTimeseriesReq::__set_tagsList(const std::vector<std::map<std::string, std::string> > & val) {
  this->tagsList = val;
__isset.tagsList = true;
}

void TSCreateMultiTimeseriesReq::__set_attributesList(const std::vector<std::map<std::string, std::string> > & val) {
  this->attributesList = val;
__isset.attributesList = true;
}

void TSCreateMultiTimeseriesReq::__set_measurementAliasList(const std::vector<std::string> & val) {
  this->measurementAliasList = val;
__isset.measurementAliasList = true;
}
std::ostream& operator<<(std::ostream& out, const TSCreateMultiTimeseriesReq& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t TSCreateMultiTimeseriesReq::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_sessionId = false;
  bool isset_paths = false;
  bool isset_dataTypes = false;
  bool isset_encodings = false;
  bool isset_compressors = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->paths.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _etype271;
            xfer += iprot->readListBegin(_etype271, _size268);
            this->paths.resize(_size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              xfer += iprot->readString(this->paths[_i272]);
            }
            xfer += iprot->readListEnd();
          }
          isset_paths = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataTypes.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readListBegin(_etype276, _size273);
            this->dataTypes.resize(_size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              xfer += iprot->readI32(this->dataTypes[_i277]);
            }
            xfer += iprot->readListEnd();
          }
          isset_dataTypes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->encodings.clear();
            uint32_t _size278;
            ::apache::thrift::protocol::TType _etype281;
            xfer += iprot->readListBegin(_etype281, _size278);
            this->encodings.resize(_size278);
            uint32_t _i282;
            for (_i282 = 0; _i282 < _size278; ++_i282)
            {
              xfer += iprot->readI32(this->encodings[_i282]);
            }
            xfer += iprot->readListEnd();
          }
          isset_encodings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compressors.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->compressors.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              xfer += iprot->readI32(this->compressors[_i287]);
            }
            xfer += iprot->readListEnd();
          }
          isset_compressors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->propsList.clear();
            uint32_t _size288;
            ::apache::thrift::protocol::TType _etype291;
            xfer += iprot->readListBegin(_etype291, _size288);
            this->propsList.resize(_size288);
            uint32_t _i292;
            for (_i292 = 0; _i292 < _size288; ++_i292)
            {
              {
                this->propsList[_i292].clear();
                uint32_t _size293;
                ::apache::thrift::protocol::TType _ktype294;
                ::apache::thrift::protocol::TType _vtype295;
                xfer += iprot->readMapBegin(_ktype294, _vtype295, _size293);
                uint32_t _i297;
                for (_i297 = 0; _i297 < _size293; ++_i297)
                {
                  std::string _key298;
                  xfer += iprot->readString(_key298);
                  std::string& _val299 = this->propsList[_i292][_key298];
                  xfer += iprot->readString(_val299);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.propsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tagsList.clear();
            uint32_t _size300;
            ::apache::thrift::protocol::TType _etype303;
            xfer += iprot->readListBegin(_etype303, _size300);
            this->tagsList.resize(_size300);
            uint32_t _i304;
            for (_i304 = 0; _i304 < _size300; ++_i304)
            {
              {
                this->tagsList[_i304].clear();
                uint32_t _size305;
                ::apache::thrift::protocol::TType _ktype306;
                ::apache::thrift::protocol::TType _vtype307;
                xfer += iprot->readMapBegin(_ktype306, _vtype307, _size305);
                uint32_t _i309;
                for (_i309 = 0; _i309 < _size305; ++_i309)
                {
                  std::string _key310;
                  xfer += iprot->readString(_key310);
                  std::string& _val311 = this->tagsList[_i304][_key310];
                  xfer += iprot->readString(_val311);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tagsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->attributesList.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->attributesList.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              {
                this->attributesList[_i316].clear();
                uint32_t _size317;
                ::apache::thrift::protocol::TType _ktype318;
                ::apache::thrift::protocol::TType _vtype319;
                xfer += iprot->readMapBegin(_ktype318, _vtype319, _size317);
                uint32_t _i321;
                for (_i321 = 0; _i321 < _size317; ++_i321)
                {
                  std::string _key322;
                  xfer += iprot->readString(_key322);
                  std::string& _val323 = this->attributesList[_i316][_key322];
                  xfer += iprot->readString(_val323);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.attributesList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->measurementAliasList.clear();
            uint32_t _size324;
            ::apache::thrift::protocol::TType _etype327;
            xfer += iprot->readListBegin(_etype327, _size324);
            this->measurementAliasList.resize(_size324);
            uint32_t _i328;
            for (_i328 = 0; _i328 < _size324; ++_i328)
            {
              xfer += iprot->readString(this->measurementAliasList[_i328]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.measurementAliasList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_paths)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataTypes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_encodings)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_compressors)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t TSCreateMultiTimeseriesReq::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TSCreateMultiTimeseriesReq");

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("paths", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->paths.size()));
    std::vector<std::string> ::const_iterator _iter329;
    for (_iter329 = this->paths.begin(); _iter329 != this->paths.end(); ++_iter329)
    {
      xfer += oprot->writeString((*_iter329));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataTypes", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->dataTypes.size()));
    std::vector<int32_t> ::const_iterator _iter330;
    for (_iter330 = this->dataTypes.begin(); _iter330 != this->dataTypes.end(); ++_iter330)
    {
      xfer += oprot->writeI32((*_iter330));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("encodings", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->encodings.size()));
    std::vector<int32_t> ::const_iterator _iter331;
    for (_iter331 = this->encodings.begin(); _iter331 != this->encodings.end(); ++_iter331)
    {
      xfer += oprot->writeI32((*_iter331));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compressors", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->compressors.size()));
    std::vector<int32_t> ::const_iterator _iter332;
    for (_iter332 = this->compressors.begin(); _iter332 != this->compressors.end(); ++_iter332)
    {
      xfer += oprot->writeI32((*_iter332));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.propsList) {
    xfer += oprot->writeFieldBegin("propsList", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->propsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter333;
      for (_iter333 = this->propsList.begin(); _iter333 != this->propsList.end(); ++_iter333)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter333).size()));
          std::map<std::string, std::string> ::const_iterator _iter334;
          for (_iter334 = (*_iter333).begin(); _iter334 != (*_iter333).end(); ++_iter334)
          {
            xfer += oprot->writeString(_iter334->first);
            xfer += oprot->writeString(_iter334->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagsList) {
    xfer += oprot->writeFieldBegin("tagsList", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->tagsList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter335;
      for (_iter335 = this->tagsList.begin(); _iter335 != this->tagsList.end(); ++_iter335)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter335).size()));
          std::map<std::string, std::string> ::const_iterator _iter336;
          for (_iter336 = (*_iter335).begin(); _iter336 != (*_iter335).end(); ++_iter336)
          {
            xfer += oprot->writeString(_iter336->first);
            xfer += oprot->writeString(_iter336->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.attributesList) {
    xfer += oprot->writeFieldBegin("attributesList", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->attributesList.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter337;
      for (_iter337 = this->attributesList.begin(); _iter337 != this->attributesList.end(); ++_iter337)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter337).size()));
          std::map<std::string, std::string> ::const_iterator _iter338;
          for (_iter338 = (*_iter337).begin(); _iter338 != (*_iter337).end(); ++_iter338)
          {
            xfer += oprot->writeString(_iter338->first);
            xfer += oprot->writeString(_iter338->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.measurementAliasList) {
    xfer += oprot->writeFieldBegin("measurementAliasList", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->measurementAliasList.size()));
      std::vector<std::string> ::const_iterator _iter339;
      for (_iter339 = this->measurementAliasList.begin(); _iter339 != this->measurementAliasList.end(); ++_iter339)
      {
        xfer += oprot->writeString((*_iter339));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TSCreateMultiTimeseriesReq &a, TSCreateMultiTimeseriesReq &b) {
  using ::std::swap;
  swap(a.sessionId, b.sessionId);
  swap(a.paths, b.paths);
  swap(a.dataTypes, b.dataTypes);
  swap(a.encodings, b.encodings);
  swap(a.compressors, b.compressors);
  swap(a.propsList, b.propsList);
  swap(a.tagsList, b.tagsList);
  swap(a.attributesList, b.attributesList);
  swap(a.measurementAliasList, b.measurementAliasList);
  swap(a.__isset, b.__isset);
}

TSCreateMultiTimeseriesReq::TSCreateMultiTimeseriesReq(const TSCreateMultiTimeseriesReq& other340) {
  sessionId = other340.sessionId;
  paths = other340.paths;
  dataTypes = other340.dataTypes;
  encodings = other340.encodings;
  compressors = other340.compressors;
  propsList = other340.propsList;
  tagsList = other340.tagsList;
  attributesList = other340.attributesList;
  measurementAliasList = other340.measurementAliasList;
  __isset = other340.__isset;
}
TSCreateMultiTimeseriesReq& TSCreateMultiTimeseriesReq::operator=(const TSCreateMultiTimeseriesReq& other341) {
  sessionId = other341.sessionId;
  paths = other341.paths;
  dataTypes = other341.dataTypes;
  encodings = other341.encodings;
  compressors = other341.compressors;
  propsList = other341.propsList;
  tagsList = other341.tagsList;
  attributesList = other341.attributesList;
  measurementAliasList = other341.measurementAliasList;
  __isset = other341.__isset;
  return *this;
}
void TSCreateMultiTimeseriesReq::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TSCreateMultiTimeseriesReq(";
  out << "sessionId=" << to_string(sessionId);
  out << ", " << "paths=" << to_string(paths);
  out << ", " << "dataTypes=" << to_string(dataTypes);
  out << ", " << "encodings=" << to_string(encodings);
  out << ", " << "compressors=" << to_string(compressors);
  out << ", " << "propsList="; (__isset.propsList ? (out << to_string(propsList)) : (out << "<null>"));
  out << ", " << "tagsList="; (__isset.tagsList ? (out << to_string(tagsList)) : (out << "<null>"));
  out << ", " << "attributesList="; (__isset.attributesList ? (out << to_string(attributesList)) : (out << "<null>"));
  out << ", " << "measurementAliasList="; (__isset.measurementAliasList ? (out << to_string(measurementAliasList)) : (out << "<null>"));
  out << ")";
}


ServerProperties::~ServerProperties() noexcept {
}


void ServerProperties::__set_version(const std::string& val) {
  this->version = val;
}

void ServerProperties::__set_supportedTimeAggregationOperations(const std::vector<std::string> & val) {
  this->supportedTimeAggregationOperations = val;
}

void ServerProperties::__set_timestampPrecision(const std::string& val) {
  this->timestampPrecision = val;
}
std::ostream& operator<<(std::ostream& out, const ServerProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ServerProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_version = false;
  bool isset_supportedTimeAggregationOperations = false;
  bool isset_timestampPrecision = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          isset_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->supportedTimeAggregationOperations.clear();
            uint32_t _size342;
            ::apache::thrift::protocol::TType _etype345;
            xfer += iprot->readListBegin(_etype345, _size342);
            this->supportedTimeAggregationOperations.resize(_size342);
            uint32_t _i346;
            for (_i346 = 0; _i346 < _size342; ++_i346)
            {
              xfer += iprot->readString(this->supportedTimeAggregationOperations[_i346]);
            }
            xfer += iprot->readListEnd();
          }
          isset_supportedTimeAggregationOperations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->timestampPrecision);
          isset_timestampPrecision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_supportedTimeAggregationOperations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_timestampPrecision)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ServerProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerProperties");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("supportedTimeAggregationOperations", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->supportedTimeAggregationOperations.size()));
    std::vector<std::string> ::const_iterator _iter347;
    for (_iter347 = this->supportedTimeAggregationOperations.begin(); _iter347 != this->supportedTimeAggregationOperations.end(); ++_iter347)
    {
      xfer += oprot->writeString((*_iter347));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestampPrecision", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->timestampPrecision);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerProperties &a, ServerProperties &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.supportedTimeAggregationOperations, b.supportedTimeAggregationOperations);
  swap(a.timestampPrecision, b.timestampPrecision);
}

ServerProperties::ServerProperties(const ServerProperties& other348) {
  version = other348.version;
  supportedTimeAggregationOperations = other348.supportedTimeAggregationOperations;
  timestampPrecision = other348.timestampPrecision;
}
ServerProperties& ServerProperties::operator=(const ServerProperties& other349) {
  version = other349.version;
  supportedTimeAggregationOperations = other349.supportedTimeAggregationOperations;
  timestampPrecision = other349.timestampPrecision;
  return *this;
}
void ServerProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerProperties(";
  out << "version=" << to_string(version);
  out << ", " << "supportedTimeAggregationOperations=" << to_string(supportedTimeAggregationOperations);
  out << ", " << "timestampPrecision=" << to_string(timestampPrecision);
  out << ")";
}


